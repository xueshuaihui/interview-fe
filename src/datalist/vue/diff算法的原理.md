## 6. diff算法的原理

### 6.1. 核心策略

**分层比较**：Diff 算法只会对同一层级的节点进行比较，不会跨层级比较。这大大减少了比较的复杂度。

**使用唯一**`key`：在使用`v - for`指令渲染列表时，Vue 要求开发者提供唯一的`key`值。`key`用于帮助 Diff 算法准确识别每个节点的身份，从而在节点顺序变化时能正确地复用和移动节点。

### 6.2. 比较过程

#### 6.2.1. 初始化比较

Diff 算法开始时，分别从新旧虚拟 DOM 树的根节点开始，按照层级顺序进行比较。例如，假设有新旧两棵虚拟 DOM 树，新树为`newTree`，旧树为`oldTree`，从它们的根节点`newTree.root`和`oldTree.root`开始比较。

#### 6.2.2. **节点类型比较**

首先比较两个节点的类型（标签名），如果节点类型不同，那么直接认为这两个节点及其子树完全不同，会将旧节点移除，在相应位置插入新节点。例如，旧节点是`<div>`，新节点是`<p>`，则直接删除旧的`<div>`节点，插入新的`<p>`节点。

#### 6.2.3. **节点类型相同时**

如果节点类型相同，接着比较节点的`key`值（如果有）和属性以及子节点（如果有）。

##### 6.2.3.1. `key`**值不同**

若`key`值不同，即使标签名和属性都相同，也会认为是不同的节点，同样会删除旧节点，插入新节点。例如，两个`<li>`标签，标签名相同，属性也相同，但`key`值不同，Diff 算法会将它们视为不同节点处理。

##### 6.2.3.2. `key`**值相同**

当`key`值相同且标签名相同时，比较节点的属性。对于属性的变化，会更新真实 DOM 上相应的属性。例如，旧节点`<div class="old - class"></div>`，新节点`<div class="new - class"></div>`，会更新真实 DOM 中`<div>`元素的`class`属性。

##### 6.2.3.3. **比较子节点**

-   **新节点有子节点，旧节点没有**：直接将新节点的子节点插入到真实 DOM 中对应位置。
-   **旧节点有子节点，新节点没有**：直接从真实 DOM 中移除旧节点的子节点。
-   **新旧节点都有子节点**：此时会采用双端比较法。分别从新旧子节点数组的两端开始比较，即开始位置（索引为 0）和结束位置（索引为 length - 1）。假设有新旧两个子节点数组`oldChildren`和`newChildren`：
-   **旧前与新前比较**：比较`oldChildren[0]`和`newChildren[0]`，如果相同（标签和`key`都相同），则将这两个节点视为相同节点，继续比较下一组（`oldChildren[1]`和`newChildren[1]`），同时旧节点和新节点的起始索引都向后移动一位。

<!---->

-   -   **旧后与新后比较**：比较`oldChildren[oldChildren.length - 1]`和`newChildren[newChildren.length - 1]`，如果相同，则视为相同节点，继续比较下一组，同时旧节点和新节点的结束索引都向前移动一位。
    -   **旧前与新后比较**：比较`oldChildren[0]`和`newChildren[newChildren.length - 1]`，如果相同，将旧节点数组起始位置的节点移动到旧节点数组的结束位置，同时旧节点起始索引向后移动一位，新节点结束索引向前移动一位。
    -   **旧后与新前比较**：比较`oldChildren[oldChildren.length - 1]`和`newChildren[0]`，如果相同，将旧节点数组结束位置的节点移动到旧节点数组的起始位置，同时旧节点结束索引向前移动一位，新节点起始索引向后移动一位。
    -   **遍历查找**：如果以上四种情况都不满足，会在旧子节点数组中查找与`newChildren[0]`（新节点起始位置的节点）`key`相同的节点。如果找到，将其移动到旧子节点数组的起始位置，并更新相关索引；如果没找到，则认为这是一个新节点，插入到真实 DOM 对应位置。

### 6.3. 生成更新补丁

在比较过程中，Diff 算法会记录下所有的变化，生成一个更新补丁（patch）。这个补丁描述了如何将旧的真实 DOM 转换为新的真实 DOM，包含了节点的新增、删除、移动和属性更新等操作。最后，Vue 会根据这个更新补丁，将变化应用到真实 DOM 上，完成视图的更新。


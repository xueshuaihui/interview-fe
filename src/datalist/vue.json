[
  {
    "id": "SPA首屏为什么加载慢？",
    "title": "2. SPA首屏为什么加载慢？",
    "answer": "### 2.1. 原因\n\n资源体积过大\n\n资源请求过多\n\njs执行阻塞\n\n样式渲染阻塞\n\n框架初始化过慢\n\n### 2.2. 优化\n\n资源加载优化：代码拆分、懒加载、资源预加载、预渲染\n\n减少资源体积：代码压缩、图片优化\n\n渲染优化：避免阻塞渲染(css放头部、js异步加载)、优化js执行（减少首屏js的执行量）\n\n网络优化：cdn加速、合并请求、缓存数据"
  },
  {
    "id": "Vue中的computed如何监听数组的变化？",
    "title": "## 11. Vue中的computed如何监听数组的变化？",
    "answer": "在 Vue 中，`computed` 属性可以用来监听数据的变化并根据依赖的数据进行计算。然而，默认情况下，`computed` 并不会直接监听数组的变化，除非数组引用发生变化（例如，整个数组被替换）。具体来说：\n\n### 11.1. **数组的变化类型**\n\n- **引用变化**：如果数组的引用发生变化（例如，`array = newArray`），`computed` 会触发重新计算。\n- **元素变化**：如果数组中的元素发生变化（例如，修改数组中的某个项），`computed` 默认不会触发重新计算\n\n### 11.2. computed监听数组变化\n\n#### 11.2.1. **方法一：使用数组变更方法**\n\nVue 提供了一些数组变更方法（如 `push`、`pop`、`shift`、`unshift`、`splice` 等），这些方法会触发 Vue 的响应式更新机制，从而让 `computed` 属性重新计算。\n\n#### 11.2.2. **使用** `watch` **监听数组变化**\n\n如果你需要在数组变化时执行更复杂的逻辑，可以使用 `watch` 来监听数组的变化。\n\n#### 11.2.3. **使用** `Vue.set` **或** `this.$set`\n\n如果你直接修改数组中的某个元素（而不是使用数组变更方法），可以使用 `Vue.set` 或 `this.$set` 来触发响应式更新。"
  },
  {
    "id": "Vue是怎样依赖收集的？",
    "title": "## 9. Vue是怎样依赖收集的？",
    "answer": "### 9.1. **核心概念**\n\n1. **响应式对象**  \n    通过 `Object.defineProperty` (Vue 2) 或 `Proxy` (Vue 3) 劫持数据访问，将普通对象转为响应式对象。\n1. **依赖（Dep）**  \n    每个响应式属性对应一个 `Dep` 实例，用于管理所有依赖该属性的观察者（Watcher）。\n1. **观察者（Watcher）**  \n    表示一个依赖关系，如组件渲染函数、计算属性或用户自定义的 `watch`。当数据变化时，`Watcher` 负责执行更新。\n\n### 9.2. 依赖收集流程\n\n#### 9.2.1. **Vue 2 的依赖收集（基于 Object.defineProperty）**\n\n- - **步骤**：\n\n1. 1. 1. **初始化响应式数据**：  \n            递归遍历对象，为每个属性创建 `Dep` 并劫持 `getter/setter`。\n\n```\nfunction defineReactive(obj, key) {\n  const dep = new Dep();  // 每个属性一个 Dep\n  let value = obj[key];\n  Object.defineProperty(obj, key, {\n    get() {\n      if (Dep.target) {  // 当前正在计算的 Watcher\n        dep.depend();   // 将 Watcher 添加到 Dep\n      }\n      return value;\n    },\n    set(newVal) {\n      value = newVal;\n      dep.notify();      // 通知所有 Watcher 更新\n    }\n  });\n}\n```\n\n1. 1. 2. **组件初始化时创建 Watcher**：  \n            每个组件实例对应一个渲染 `Watcher`，在 `mount` 阶段首次执行渲染函数。\n        2. **触发依赖收集**：  \n            渲染过程中访问数据属性，触发 `getter`，将当前 `Watcher` 收集到属性的 `Dep` 中。\n\n- - **依赖关系示例**：\n\n```\n// 数据\nconst data = { count: 0 };\n// 转为响应式\nobserve(data);\n\n// 组件 Watcher\nnew Watcher(() => {\n  console.log(data.count);  // 访问 count，触发 getter\n});\n\n// 输出：0\ndata.count = 1;  // 触发 setter，Watcher 重新执行\n```\n\n#### 9.2.2. **Vue 3 的依赖收集（基于 Proxy）**\n\n- **步骤**：\n\n1. 1. **创建响应式对象**：  \n        使用 `Proxy` 拦截对象操作，无需递归初始化。\n\n```\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key, receiver) {\n      track(target, key);  // 依赖收集\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, value, receiver) {\n      Reflect.set(target, key, value, receiver);\n      trigger(target, key);  // 触发更新\n    }\n  });\n}\n```\n\n1. 2. **全局依赖管理**：  \n        通过 `track` 函数将当前活动的 `effect`（类似 Watcher）记录到全局的 `targetMap` 中。\n    2. **依赖触发**：  \n        数据修改时，`trigger` 函数从 `targetMap` 中找到依赖并执行。\n\n### 9.3. 注意\n\n#### 9.3.1. **Dep 与 Watcher 的多对多关系**\n\n- **Dep → Watcher**：一个属性可被多个组件或计算属性依赖。\n- **Watcher → Dep**：一个 `Watcher` 可能依赖多个属性（如模板中使用多个数据）。\n\n#### 9.3.2. **2. 避免重复收集**\n\n- **Vue 2**：通过 `Dep.target` 标识当前 `Watcher`，确保同一 `Watcher` 不会重复添加到 `Dep`。\n- **Vue 3**：使用 `activeEffect` 和 `effectStack` 管理当前活动的副作用。\n\n#### 9.3.3. **3. 嵌套组件的依赖收集**\n\n- 父组件渲染时遇到子组件，会先完成子组件的依赖收集，再回到父组件。\n\n### 9.4. **依赖更新的触发**\n\n#### 9.4.1. **同步更新流程**\n\n```\ngraph TD\n  A[数据修改] --> B[触发 setter/Proxy set]\n  B --> C[Dep.notify / trigger]\n  C --> D[遍历所有 Watcher/Effect]\n  D --> E[执行 Watcher.run / effect scheduler]\n  E --> F[重新渲染或执行回调]\n```\n\n#### 9.4.2. **异步更新流程**\n\n**批量更新优化**：  \n多次数据修改会合并到一次更新中，避免重复渲染。\n\n### 9.5. **特殊场景处理**\n\n#### 9.5.1. **数组的依赖收集**\n\n- **Vue 2**：重写数组方法（`push`、`pop` 等），在方法调用时手动触发通知。\n- **Vue 3**：`Proxy` 直接监听数组索引变化和方法调用。\n\n#### 9.5.2. **2. 计算属性与侦听器**\n\n- **计算属性**：  \n    惰性求值，只有当依赖变化时才重新计算。\n- **侦听器（watch）** ：  \n    显式指定依赖源，变化时触发回调。"
  },
  {
    "id": "diff算法的原理",
    "title": "## 6. diff算法的原理",
    "answer": "### 6.1. 核心策略\n\n**分层比较**：Diff 算法只会对同一层级的节点进行比较，不会跨层级比较。这大大减少了比较的复杂度。\n\n**使用唯一**`key`：在使用`v - for`指令渲染列表时，Vue 要求开发者提供唯一的`key`值。`key`用于帮助 Diff 算法准确识别每个节点的身份，从而在节点顺序变化时能正确地复用和移动节点。\n\n### 6.2. 比较过程\n\n#### 6.2.1. 初始化比较\n\nDiff 算法开始时，分别从新旧虚拟 DOM 树的根节点开始，按照层级顺序进行比较。例如，假设有新旧两棵虚拟 DOM 树，新树为`newTree`，旧树为`oldTree`，从它们的根节点`newTree.root`和`oldTree.root`开始比较。\n\n#### 6.2.2. **节点类型比较**\n\n首先比较两个节点的类型（标签名），如果节点类型不同，那么直接认为这两个节点及其子树完全不同，会将旧节点移除，在相应位置插入新节点。例如，旧节点是`<div>`，新节点是`<p>`，则直接删除旧的`<div>`节点，插入新的`<p>`节点。\n\n#### 6.2.3. **节点类型相同时**\n\n如果节点类型相同，接着比较节点的`key`值（如果有）和属性以及子节点（如果有）。\n\n##### 6.2.3.1. `key`**值不同**\n\n若`key`值不同，即使标签名和属性都相同，也会认为是不同的节点，同样会删除旧节点，插入新节点。例如，两个`<li>`标签，标签名相同，属性也相同，但`key`值不同，Diff 算法会将它们视为不同节点处理。\n\n##### 6.2.3.2. `key`**值相同**\n\n当`key`值相同且标签名相同时，比较节点的属性。对于属性的变化，会更新真实 DOM 上相应的属性。例如，旧节点`<div class=\"old - class\"></div>`，新节点`<div class=\"new - class\"></div>`，会更新真实 DOM 中`<div>`元素的`class`属性。\n\n##### 6.2.3.3. **比较子节点**\n\n-   **新节点有子节点，旧节点没有**：直接将新节点的子节点插入到真实 DOM 中对应位置。\n-   **旧节点有子节点，新节点没有**：直接从真实 DOM 中移除旧节点的子节点。\n-   **新旧节点都有子节点**：此时会采用双端比较法。分别从新旧子节点数组的两端开始比较，即开始位置（索引为 0）和结束位置（索引为 length - 1）。假设有新旧两个子节点数组`oldChildren`和`newChildren`：\n-   **旧前与新前比较**：比较`oldChildren[0]`和`newChildren[0]`，如果相同（标签和`key`都相同），则将这两个节点视为相同节点，继续比较下一组（`oldChildren[1]`和`newChildren[1]`），同时旧节点和新节点的起始索引都向后移动一位。\n\n<!---->\n\n-   -   **旧后与新后比较**：比较`oldChildren[oldChildren.length - 1]`和`newChildren[newChildren.length - 1]`，如果相同，则视为相同节点，继续比较下一组，同时旧节点和新节点的结束索引都向前移动一位。\n    -   **旧前与新后比较**：比较`oldChildren[0]`和`newChildren[newChildren.length - 1]`，如果相同，将旧节点数组起始位置的节点移动到旧节点数组的结束位置，同时旧节点起始索引向后移动一位，新节点结束索引向前移动一位。\n    -   **旧后与新前比较**：比较`oldChildren[oldChildren.length - 1]`和`newChildren[0]`，如果相同，将旧节点数组结束位置的节点移动到旧节点数组的起始位置，同时旧节点结束索引向前移动一位，新节点起始索引向后移动一位。\n    -   **遍历查找**：如果以上四种情况都不满足，会在旧子节点数组中查找与`newChildren[0]`（新节点起始位置的节点）`key`相同的节点。如果找到，将其移动到旧子节点数组的起始位置，并更新相关索引；如果没找到，则认为这是一个新节点，插入到真实 DOM 对应位置。\n\n### 6.3. 生成更新补丁\n\n在比较过程中，Diff 算法会记录下所有的变化，生成一个更新补丁（patch）。这个补丁描述了如何将旧的真实 DOM 转换为新的真实 DOM，包含了节点的新增、删除、移动和属性更新等操作。最后，Vue 会根据这个更新补丁，将变化应用到真实 DOM 上，完成视图的更新。"
  },
  {
    "id": "nextTick的理解",
    "title": "## 7. nextTick的理解",
    "answer": "### 7.1. **Vue 的异步更新队列**\n\n- **数据变化不会立即更新 DOM**：当数据变化时，Vue 将组件更新推入一个队列，并在同一事件循环（Event Loop）中缓冲所有数据变更。\n- **合并重复操作**：避免同一数据多次修改导致的重复渲染，提升性能。\n\n### 7.2. `nextTick` **的作用**\n\n- **延迟回调执行**：将回调函数推迟到**下一个 DOM 更新周期之后执行**，确保能访问到更新后的 DOM。\n\n### 7.3. **实现机制**\n\n- **底层基于事件循环**：Vue 内部优先使用微任务（Microtask）：\n\n<!---->\n\n- - 支持环境：`Promise.then` → `MutationObserver` → `setImmediate` → `setTimeout`（降级方案）\n\n<!---->\n\n- **保证执行时机**：在浏览器完成 DOM 更新后触发回调。"
  },
  {
    "id": "vue-router的原理是什么？",
    "title": "## 1. vue-router的原理是什么？",
    "answer": "Vue Router 的核心是通过 **路由模式监听 URL 变化** → **动态匹配组件** → **响应式更新视图**，实现单页面应用的无刷新导航。选择 Hash 或 History 模式需根据项目需求权衡美观性、兼容性和服务器支持。对于复杂场景，可结合导航守卫、懒加载等特性优化用户体验\n\n### 路由模式的核心实现\n\nVue Router 支持三种路由模式，其底层机制如下：\n\n1. **Hash 模式（默认模式）**\n\n- **原理**：利用 URL 中的 `#` 符号（哈希值）作为路由标识。哈希值的变化不会触发浏览器向服务器发送请求。\n- **实现方式**：\n\n<!---->\n\n- - 通过 `window.addEventListener('hashchange', callback)` 监听哈希变化。\n  - 哈希值变化时，解析路径并匹配对应组件，通过 `<router-view>` 动态渲染。\n\n<!---->\n\n- **优点**：兼容性好（支持所有浏览器），无需服务器配置。\n- **缺点**：URL 中带有 `#`，不够美观。\n\n2. **History 模式**\n\n- **原理**：基于 HTML5 的 `History API`（`pushState` 和 `replaceState`），直接操作浏览器历史记录栈。\n- **实现方式**：\n\n<!---->\n\n- - 通过 `history.pushState()` 或 `history.replaceState()` 修改 URL。\n  - 通过 `window.addEventListener('popstate', callback)` 监听浏览器前进/后退操作。\n\n<!---->\n\n- **优点**：URL 无 `#`，更符合传统 URL 结构。\n- **缺点**：需服务器配置（所有路径重定向到 `index.html`），否则直接访问子路径会返回 404。\n\n3. **Memory** **模式**\n\n- **原理**：通过数组模拟浏览器历史记录栈，不依赖浏览器 API，适用于非浏览器环境（如 Node.js 或移动端）\n\n### Vue Router 的核心工作流程\n\n1. **初始化路由表**  \n    定义路由配置（`routes` 数组），将路径与组件映射。例如：\n\n```\njavascript\n\n\nconst routes = [\n  { path: '/user/:id', component: User }, // 动态路由\n  { path: '/parent', component: Parent, children: [...] } // 嵌套路由\n];\n```\n\n2. **监听 URL 变化**\n\n- - Hash 模式监听 `hashchange` 事件，History 模式监听 `popstate` 事件。\n\n3. **动态匹配路由**\n\n- - 根据当前 URL 解析路径参数（如 `/user/123` 中的 `id=123`），匹配路由表中对应的组件。\n\n4. **组件渲染**\n\n- - 通过 `<router-view>` 组件作为占位符，动态渲染匹配到的组件。\n\n5. **状态更新**\n\n- - 使用响应式变量（如 `current`）跟踪当前路由状态，触发视图更新。\n\n### 关键特性与进阶实现\n\n#### 1. **动态路由与嵌套路由**\n\n- **动态路由**：通过冒号 `:` 定义路径参数（如 `/user/:id`），在组件中通过 `$route.params` 获取参数。\n- **嵌套路由**：通过 `children` 配置子路由，父组件中嵌套 `<router-view>` 渲染子组件。\n\n#### 2. **导航守卫**\n\n- **作用**：在路由跳转前后执行逻辑（如权限验证、数据预加载）。\n- **类型**：\n\n<!---->\n\n- - 全局守卫（`router.beforeEach`）。\n  - 路由独享守卫（`beforeEnter`）。\n  - 组件内守卫（`beforeRouteEnter`、`beforeRouteLeave`）。\n\n#### 3. **懒加载**\n\n- **实现**：通过动态导入语法（`() => import('./Component.vue')`）按需加载组件，提升首屏性能\n\n### **Hash 模式和History 模式**对比\n\n| **对比维度**    | **Hash 模式** | **History 模式**                |\n| ----------- | ----------- | ----------------------------- |\n| **URL 美观性** | 带有 `#`      | 无 `#`，更接近传统 URL               |\n| **兼容性**     | 支持所有浏览器     | 需浏览器支持 History API            |\n| **服务器配置**   | 无需特殊配置      | 需配置重定向（如 Nginx 的 `try_files`） |\n| **适用场景**    | 简单项目、兼容性要求高 | 需 SEO 优化、URL 美观的正式项目          |"
  },
  {
    "id": "为什么Vue被称为“渐进框架”？",
    "title": "1. 为什么Vue被称为“渐进框架”？",
    "answer": "## 什么是渐进式框架\n\n渐进式框架是一种软件开发框架，它允许开发者根据项目的规模、复杂度和需求，逐步引入框架的功能，而不是一开始就采用框架的全部特性和复杂架构。\n\n## 为什么vue是渐进式框架\n\nVue 被称为渐进式框架，主要原因在于它允许开发者根据项目的实际需求，逐步、灵活地引入框架功能，在不同阶段以不同方式使用 Vue，具体表现如下：\n\n1. **使用方式灵活，易于集成**\n\nVue 能以非常轻量的方式嵌入到现有项目中。只需在 HTML 页面引入 Vue 的脚本文件，就可以通过简单的指令实现数据绑定和基本交互\n\n2. **功能逐步集成**\n\n随着项目的发展，开发者可以按需逐步集成 Vue 的更多高级功能.比如基础组件逐步组装为复杂组件\n\n3. **适配不同规模项目**\n\n小型项目友好，大型项目可扩展性强，这也是依赖于vue的简单灵活和生态的完备\n\n4. **学习成本低且可渐进提升**\n\nVue 的 API 设计简洁明了，对于初学者而言，容易理解和上手。随着对 Vue 基础功能的熟悉，开发者可以逐步深入学习更高级的特性"
  },
  {
    "id": "你知道v-model的原理吗？说说看",
    "title": "## 8. 你知道v-model的原理吗？说说看",
    "answer": "### 8.1. **表单元素中的** `v-model`\n\n#### 8.1.1. **基础实现,input标签**\n\n```\n<input v-model=\"message\">\n```\n\n等价于\n\n```\n<input \n  :value=\"message\" \n  @input=\"message = $event.target.value\"\n>\n```\n\n**原理**：\n\n- **属性绑定**：将数据 `message` 绑定到 `value` 属性。\n- **事件监听**：监听 `input` 事件，更新数据到 `message`。\n\n#### 8.1.2. **其他表单元素的适配**\n\n- `<textarea>`：与 `<input>` 相同。\n- `<select>`：监听 `change` 事件。\n- 复选框（Checkbox）和单选框（Radio）：处理 `checked` 属性和 `change` 事件。\n\n### 8.2. **组件中的** `v-model`\n\n#### 8.2.1. vue2\n\n**默认行为**：\n\n- **Prop**：`value`\n- **事件**：`input`\n\n```\n<!-- 父组件 -->\n<ChildComponent v-model=\"message\" />\n```\n\n等价于\n\n```\n<ChildComponent \n  :value=\"message\" \n  @input=\"message = $event\"\n/>\n```\n\n**自定义修改**：  \n通过 `model` 选项可修改默认的 prop 和事件名：\n\n```\n// 子组件\nexport default {\n  model: {\n    prop: 'title',    // 修改 prop 名为 title\n    event: 'change'   // 修改事件名为 change\n  }\n}\n```\n\n#### 8.2.2. vue3\n\n**默认行为**：\n\n- **Prop**：`modelValue`\n- **事件**：`update:modelValue`\n\n```\n<!-- 父组件 -->\n<ChildComponent v-model=\"message\" />\n```\n\n等价于\n\n```\n<ChildComponent \n  :modelValue=\"message\" \n  @update:modelValue=\"message = $event\"\n/>\n```\n\n### 8.3. 底层实现\n\n#### 8.3.1. **1. 数据 → 视图（响应式更新）**\n\n- **依赖追踪**：通过响应式系统（如 `Object.defineProperty` 或 `Proxy`），当数据变化时，触发组件的重新渲染。\n- **虚拟 DOM 对比**：生成新的虚拟 DOM 并与旧 DOM 对比，更新变化的部分。\n\n#### 8.3.2. **2. 视图 → 数据（事件触发）**\n\n- 监听表单输入事件（如 `input`、`change`）。\n- 在事件回调中更新数据，触发响应式系统的依赖通知。\n\n```\n数据变化 → 更新视图（响应式系统）\n视图输入 → 触发事件 → 更新数据（事件监听）\n```"
  },
  {
    "id": "你觉得虚拟DOM比真实DOM性能好吗？为什么？",
    "title": "4. 你觉得虚拟DOM比真实DOM性能好吗？为什么？",
    "answer": "在大多数情况下，虚拟 DOM 比真实 DOM 性能更好，但并非绝对，具体还得根据场景来区分：\n\n### 4.1. 虚拟DOM性能更好的原因\n\n**减少直接操作真实 DOM 的频率**\n\n-   **真实 DOM 操作代价高**：真实 DOM 是浏览器渲染页面的基础，对其进行修改（如添加、删除、移动元素）时，浏览器需要重新计算元素的布局、样式，并重新绘制页面，这是非常昂贵的操作，会消耗大量的性能。例如，当在页面中添加一个新的 DOM 元素时，浏览器需要重新计算该元素及其周围元素的位置和样式，可能还需要重新绘制整个或部分页面区域。\n-   **虚拟 DOM 的缓冲作用**：虚拟 DOM 是在 JavaScript 中以对象形式存在的轻量级数据结构，它对真实 DOM 进行了抽象。当数据发生变化时，先在虚拟 DOM 层面进行修改，然后通过比较新旧虚拟 DOM 树，计算出最小的变化集，最后将这些变化一次性应用到真实 DOM 上。这样就大大减少了直接操作真实 DOM 的次数，降低了浏览器重排和重绘的频率。比如，在一个包含 100 个列表项的列表中，如果只更新其中一项的数据，虚拟 DOM 可以精准地计算出只有这一项需要更新，而不是重新渲染整个列表。\n\n**高效的 Diff 算法**\n\n-   **快速对比差异**：虚拟 DOM 在更新时，使用 Diff 算法来比较新旧虚拟 DOM 树，找出它们之间的差异。这个算法采用了一些启发式的策略，例如只对比同一层级的节点，避免跨层级的比较，从而大大减少了比较的复杂度。在比较过程中，它能够快速确定哪些节点是新增的、哪些是需要删除的、哪些是属性发生变化的。\n-   **最小化 DOM 操作**：通过 Diff 算法计算出的差异，会生成一个最小的 DOM 操作补丁，只对需要变化的真实 DOM 部分进行更新，而不是重新构建整个 DOM 结构。例如，在一个复杂的表单中，用户只修改了一个输入框的值，Diff 算法可以精确地定位到这个输入框对应的虚拟 DOM 节点，计算出其属性或文本内容的变化，然后只更新真实 DOM 中的这个输入框元素，而不影响其他部分。\n\n### 4.2. 虚拟DOM性能不是最佳的场景\n\n**简单场景下可能优势不明显**：\n\n-   **操作简单直接**：在一些非常简单的页面或操作中，直接操作真实 DOM 可能更加高效。例如，页面上只有一个按钮，点击按钮时只是简单地修改按钮的文本内容，这种情况下直接操作真实 DOM（如`button.textContent = '新文本'`）比通过虚拟 DOM 来处理要简单直接，因为引入虚拟 DOM 会带来额外的抽象和计算开销，包括创建虚拟 DOM 对象、进行 Diff 算法计算等。\n\n**初始渲染性能**：\n\n-   **首次渲染开销**：在首次渲染时，虚拟 DOM 需要将数据转化为虚拟 DOM 树结构，然后再根据虚拟 DOM 生成真实 DOM 并插入页面。这个过程相对于直接通过模板生成真实 DOM 会有一些额外的计算开销。尤其是在页面结构简单、数据量小的情况下，这种额外开销可能会比较明显。但在大型应用中，由于后续的更新操作频繁，虚拟 DOM 在整体性能上的优势会逐渐体现出来，弥补首次渲染的微小劣势。\n\n总体而言，虚拟 DOM 在大多数复杂的前端应用场景中，通过减少真实 DOM 操作频率和利用高效的 Diff 算法，展现出比直接操作真实 DOM 更好的性能，但在简单场景或对首次渲染性能要求极高的特定情况下，其优势可能不显著甚至可能稍逊一筹。"
  },
  {
    "id": "强制更新组件的方法有哪些？分别有何利弊？",
    "title": "## 12. 强制更新组件的方法有哪些？分别有何利弊？",
    "answer": "### 12.1. `this.$forceUpdate()`\n\n#### 12.1.1. **原理**\n\n强制当前组件实例重新渲染，跳过虚拟 DOM 的 Diff 过程，直接调用 `render` 函数生成新 VNode 并更新 DOM。\n\n#### 12.1.2. **使用方式**\n\n```\n// 选项式 API\nthis.$forceUpdate();\n\n// 组合式 API（Vue 3）\nimport { getCurrentInstance } from 'vue';\nconst instance = getCurrentInstance();\ninstance.proxy.$forceUpdate();\n```\n\n#### 12.1.3. **优点**\n\n- **简单直接**：无需修改数据或结构\n- **局部更新**：仅影响当前组件及其子组件\n\n#### 12.1.4. **缺点**\n\n- **违背响应式原则**：掩盖数据未正确响应的设计问题\n- **性能损耗**：强制全组件树重新渲染，可能引发不必要的子组件更新\n- **不解决根本问题**：未修复数据响应性，后续更新仍需手动触发\n\n* * *\n\n### 12.2. **修改组件的** `key`\n\n#### 12.2.1. **原理**\n\n通过改变 `key` 值，使 Vue 认为组件已销毁并重新创建，触发完整生命周期。\n\n#### 12.2.2. **使用方式**\n\n```\n// 修改 key 值强制重建组件\nthis.componentKey = Date.now(); // 或递增计数器\n```\n\n#### 12.2.3. **优点**\n\n- **彻底重置组件状态**：适合需要完全重新初始化的场景\n- **兼容性强**：适用于任何组件和复杂场景\n\n#### 12.2.4. **缺点**\n\n- **性能开销大**：销毁和重建组件成本高，尤其是复杂组件\n- **状态丢失**：组件内部状态（如表单输入）会被重置\n- **设计异味**：可能反映组件设计存在耦合问题\n\n* * *\n\n### 12.3. **利用** `v-if` **切换**\n\n#### 12.3.1. **原理**\n\n通过 `v-if=\"show\"` 控制组件挂载/卸载，切换时重新渲染。\n\n#### 12.3.2. **使用方式**\n\n```\n// 先卸载再重新挂载\nthis.show = false;\nthis.$nextTick(() => {\n  this.show = true;\n});\n```\n\n#### 12.3.3. **优点**\n\n- **控制灵活**：可精确控制重新渲染时机\n- **类似** ****`key` ******的效果**：但保留父组件状态\n\n#### 12.3.4. **缺点**\n\n- **代码冗余**：需要手动处理状态保留逻辑\n- **闪烁问题**：快速切换可能导致界面闪烁\n- **不适用于保持内部状态**：与 `key` 类似，会丢失子组件状态\n\n* * *\n\n### 12.4. **强制更新依赖（响应式系统）**\n\n#### 12.4.1. **原理**\n\n通过修改响应式数据的引用地址，触发依赖更新。\n\n#### 12.4.2. **使用方式**\n\n```\n// 对象：替换整个对象\nthis.obj = { ...this.obj };\n\n// 数组：返回新数组\nthis.arr = this.arr.slice();\n```\n\n#### 12.4.3. **优点**\n\n- **符合响应式规范**：利用 Vue 的响应式机制\n- **精准更新**：仅触发相关依赖的重新计算\n\n#### 12.4.4. **缺点**\n\n- **仅适用于引用类型**：基础数据类型无法使用\n- **可能引发副作用**：若其他代码依赖原引用，可能导致意外行为\n\n* * *\n\n### 12.5. **使用** `Vue.set` **/** `this.$set`\n\n#### 12.5.1. **原理**\n\n显式声明新增属性为响应式，适用于动态添加未预先声明的属性。\n\n#### 12.5.2. **使用方式**\n\n```\n// Vue 2\nthis.$set(this.obj, 'newKey', 'value');\n\n// Vue 3（通常不需要，Proxy 自动检测）\nimport { set } from 'vue';\nset(this.obj, 'newKey', 'value');\n```\n\n#### 12.5.3. **优点**\n\n- **修复数据响应性**：根本解决视图不更新的问题\n- **官方推荐**：符合 Vue 设计模式\n\n#### 12.5.4. **缺点**\n\n- **局限性**：仅解决新增属性/数组索引的响应性问题\n- **需明确问题根源**：无法修复其他原因导致的更新失败\n\n* * *\n\n### 12.6. **总结与最佳实践**\n\n| **方法**           | **适用场景**      | **推荐指数** | **注意事项**          |\n| ---------------- | ------------- | -------- | ----------------- |\n| `$forceUpdate()` | 紧急修复、非响应式数据依赖 | ⭐⭐       | 避免滥用，排查数据问题       |\n| 修改 `key`         | 需要完全重置组件状态    | ⭐⭐       | 性能敏感场景慎用          |\n| `v-if`切换         | 临时强制重建组件      | ⭐        | 可能导致闪烁            |\n| 强制更新依赖           | 引用类型数据未触发更新   | ⭐⭐⭐      | 优先选择的响应式方案        |\n| `Vue.set`        | 动态添加属性/数组项未响应 | ⭐⭐⭐⭐     | Vue 2 必备，Vue 3 少用"
  },
  {
    "id": "计算属性computed和watch的区别是什么？",
    "title": "## 10. 计算属性computed和watch的区别是什么？",
    "answer": "1. **计算属性（computed）** ：\n\n- - **用途**：用于定义依赖于其他数据属性的计算值。\n  - **特点**：\n\n<!---->\n\n- - - 缓存：只有在依赖的数据变化时，才会重新计算。\n    - 自动更新：当依赖的数据变化时，计算属性会自动更新。\n\n<!---->\n\n- - **适用场景**：需要基于其他数据生成的属性，例如全名、总价等。\n\n2. **监视器（watch）** ：\n\n- - **用途**：用于在数据变化时执行特定的操作。\n  - **特点**：\n\n<!---->\n\n- - - 每次变化都会触发：无论数据是否变化，只要被监视的数据变化，就会执行回调函数。\n    - 无缓存：不进行缓存，每次变化都会执行逻辑。\n\n<!---->\n\n- - **适用场景**：需要在数据变化时执行副作用操作，比如调用API、修改其他状态等。\n\n3. **主要区别**：\n\n- - **缓存机制**：计算属性有缓存，只有依赖变化时才重新计算；监视器每次变化都会执行。\n  - **执行方式**：计算属性是被动更新，依赖变化自动触发；监视器是主动执行，变化触发回调函数。\n  - **应用场景**：计算属性适合生成依赖属性，监视器适合执行复杂逻辑或副作用操作。"
  },
  {
    "id": "请描述下虚拟DOM的解析过程",
    "title": "## 5. 请描述下虚拟DOM的解析过程",
    "answer": "### 5.1. 虚拟 DOM 的创建\n\n#### 5.1.1. **模板编译**\n\nVue 应用通常从模板开始。模板是一种接近 HTML 的语法，用于描述视图结构。Vue 的编译器（在构建过程中或运行时，取决于配置）会将模板编译成渲染函数。这个过程会解析模板中的指令（如`v-for`）、插值表达式（如`{{ message }}`）等，将其转化为 JavaScript 代码。\n\n#### 5.1.2. **渲染函数生成虚拟 DOM**\n\n渲染函数被调用时，会创建虚拟 DOM。虚拟 DOM 本质上是普通的 JavaScript 对象，它描述了真实 DOM 的结构、属性和子节点等信息。每个虚拟 DOM 节点包含标签名（`tag`）、属性（`attrs`）、文本内容（`text`）以及子节点数组（`children`）等信息。\n\n### 5.2. 虚拟 DOM 的更新\n\n#### 5.2.1. **数据变化检测**\n\nVue 通过响应式系统检测数据的变化。当响应式数据发生改变时，会触发重新渲染。\n\n#### 5.2.2. **生成新的虚拟 DOM**\n\nVue 会再次调用渲染函数，基于新的数据生成新的虚拟 DOM 树。\n\n#### 5.2.3. **Diff 算法比较新旧虚拟 DOM**\n\nVue 使用 Diff 算法来高效地比较新旧虚拟 DOM 树，找出它们之间的差异\n\n#### 5.2.4. **生成最小更新补丁**\n\n通过 Diff 算法比较后，会生成一个描述变化的最小更新补丁。\n\n### 5.3. 虚拟 DOM 更新应用到真实 DOM\n\n#### 5.3.1. **DOM 更新操作**\n\n根据生成的更新补丁，Vue 会将这些变化应用到真实 DOM 上。\n\n#### 5.3.2. **触发重排与重绘**\n\n对真实 DOM 的修改会触发浏览器的重排（重新计算布局）和重绘（重新绘制页面）。但由于 Vue 通过虚拟 DOM 和 Diff 算法尽量减少了真实 DOM 的变化，从而降低了重排和重绘的范围和频率，提高了性能。"
  },
  {
    "id": "请说说Vue.use方法的作用及原理",
    "title": "3. 请说说Vue.use方法的作用及原理",
    "answer": "### 3.1. Vue 插件的规范\n\n一个 Vue 插件通常是一个对象，这个对象需要包含一个 `install` 方法。该 `install` 方法会在调用 `Vue.use()` 时被执行。此外，插件也可以直接是一个函数，在这种情况下，这个函数会被当作 `install` 方法来执行。\n\n### 3.2. `Vue.use()` 的执行流程\n\n**检查插件是否已安装**\n\n`Vue.use()` 首先会检查要安装的插件是否已经在 `Vue._installedPlugins` 数组中。`Vue._installedPlugins` 是 Vue 内部用于记录已安装插件的数组。如果插件已在该数组中，说明插件已经安装过，`Vue.use()` 直接返回，不再重复安装。\n\n**处理参数**\n\n1. `Vue.use()` 可以接受一个插件（对象或函数）作为参数，也可以接受多个参数，第一个参数为插件，其余参数会被传递给插件的 `install` 方法。\n1. 如果传递给 `Vue.use()` 的第一个参数不是对象且不是函数，`Vue.use()` 会抛出一个错误，提示插件必须是一个对象****\n\n**调用** `install` **方法**\n\n1. 如果插件是一个对象，`Vue.use()` 会调用该对象的 `install` 方法，并将 `Vue` 构造函数作为第一个参数传递进去，如果 `Vue.use()` 有额外的参数，这些参数会紧接着 `Vue` 之后传递给 `install` 方法。\n1. 如果插件本身就是一个函数，`Vue.use()` 会直接调用这个函数，并同样将 `Vue` 构造函数作为第一个参数传递，额外参数依次往后传递。"
  },
  {
    "id": "路由守卫的执行顺序是什么？",
    "title": "",
    "answer": "## 2. 路由守卫的执行顺序是什么？\n\n### 2.1. 完整执行顺序（从路由 A 跳转到路由 B）\n\n1. **组件内离开守卫：** `beforeRouteLeave`\n\n- - **触发时机**：导航离开当前组件时（如从 A 组件跳转至 B 组件）。\n  - **作用**：处理离开前的操作（如保存未提交数据）。\n  - **注意**：可访问当前组件实例 `this`。\n\n2. **全局前置守卫：** `beforeEach`\n\n- - **触发时机**：所有路由跳转的入口拦截。\n  - **作用**：全局权限验证（如登录状态检查）。\n\n3. **路由独享守卫：** `beforeEnter`\n\n- - **触发时机**：仅针对目标路由（如 B 路由）的拦截。\n  - **作用**：特定路由的权限控制（如管理员访问限制）。\n\n4. **组件内复用守卫：** `beforeRouteUpdate`\n\n- - **触发时机**：**仅当组件复用时触发**（如动态路由参数变化，如 `/user/1` → `/user/2`）。\n  - **作用**：更新组件内数据（如重新获取用户详情）。\n\n5. **组件内进入守卫：** `beforeRouteEnter`\n\n- - **触发时机**：目标组件（B 组件）渲染前。\n  - **作用**：预加载数据（如异步请求），但**无法访问** ****`this`（需通过 `next(vm => {})` 回调获取实例）。\n\n6. **全局解析守卫：** `beforeResolve`\n\n- - **触发时机**：所有前置守卫完成后，导航确认前。\n  - **作用**：最终安全检查或数据准备（如确保所有异步操作完成）。\n\n7. **全局后置钩子：** `afterEach`\n\n- - **触发时机**：导航完成后。\n  - **作用**：执行与导航无关的后置操作（如埋点统计、页面标题更新）。\n\n* * *\n\n### 2.2. 二、特殊场景说明\n\n#### 2.2.1. 1. **组件复用时（动态路由参数变化）**\n\n- **执行顺序**：`beforeRouteLeave` → `beforeEach` → `beforeRouteUpdate` → `beforeResolve` → `afterEach`。\n- **示例**：从 `/user/1` 跳转到 `/user/2`，复用 `User` 组件，触发 `beforeRouteUpdate`。\n\n#### 2.2.2. 2. **嵌套路由跳转**\n\n- **执行顺序**：父组件的 `beforeRouteLeave` → 子组件的 `beforeRouteLeave` → 全局 `beforeEach` → 子路由的 `beforeEnter` → 子组件的 `beforeRouteEnter`。\n\n#### 2.2.3. 3. **异步组件加载**\n\n- **触发时机**：在 `beforeEnter` 和 `beforeRouteEnter` 之间解析异步组件。\n- **示例**：使用 `() => import('./User.vue')` 动态导入组件时，需等待组件加载完成。\n\n* * *\n\n### 2.3. 三、核心注意事项\n\n1. `next()`******的调用**\n\n- - **必须显式调用** `next()`，否则导航会挂起。\n  - **控制跳转**：通过 `next(false)` 中断导航，或 `next('/login')` 重定向。\n\n2. `beforeRouteEnter` ******的特殊性**\n\n- - **无法访问** ****`this`：因组件实例尚未创建，需通过 `next(vm => {})` 回调操作实例。\n  - **唯一支持回调的守卫**：其他守卫可直接访问 `this`。\n\n3. **错误处理**\n\n- - **全局错误捕获**：通过 `router.onError()` 捕获 `next(error)` 抛出的异常。\n\n### 2.4. 流程图解\n\n```\n导航触发  \n→ 调用当前组件 beforeRouteLeave  \n→ 全局 beforeEach  \n→ 目标路由 beforeEnter  \n→ （若复用组件）调用 beforeRouteUpdate  \n→ 解析异步组件  \n→ 调用目标组件 beforeRouteEnter  \n→ 全局 beforeResolve  \n→ 导航确认  \n→ 更新 DOM  \n→ 调用全局 afterEach  \n→ 执行 beforeRouteEnter 的 next 回调[5,7,9](@ref)\n```"
  }
]
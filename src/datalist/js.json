[
  {
    "id": "Event-loop",
    "title": "Event-Loop",
    "answer": "前端事件循环（Event Loop）是 JavaScript 运行时处理异步任务的核心机制，它决定了代码执行的顺序和优先级，使 JavaScript 在单线程环境中高效处理异步任务，确保用户界面的流畅性和响应性。\n\n## 单线程与异步执行的矛盾\n\nJavaScript 在浏览器环境中是单线程运行的，这意味着它同一时间只能执行一个任务。例如，当执行一段复杂的计算任务时，其他任务（如用户点击事件、页面渲染）都必须等待该计算完成。这种特性在处理需要大量时间的任务时，可能会导致页面卡顿，影响用户体验。然而，前端开发中存在许多耗时操作，如网络请求（`fetch`）、定时器（`setTimeout`、`setInterval`）等。如果这些操作都以同步方式执行，整个页面将会冻结，直到操作完成。为了解决这个矛盾，JavaScript 引入了事件循环机制，它允许在执行同步任务的同时，异步处理其他任务。\n\n## 工作原理\n\n### **调用栈**\n\n同步代码逐行执行（后进先出，LIFO）\n\n函数调用时入栈，执行完毕出栈\n\n### **任务队列**\n\n**宏任务队列（MacroTask Queue）** ：`setTimeout`、`setInterval`、DOM 事件回调、I/O 操作\n\n**微任务队列（MicroTask Queue）** ：`Promise.then`、`MutationObserver`、`queueMicrotask`\n\n**渲染管线（Render Pipeline）** ：样式计算、布局、绘制（requestAnimationFrame 回调在此阶段执行）\n\n### 事件循环流程\n\n```\nwhile (true) {\n  1. 执行调用栈中的同步代码（直到栈空）\n  2. 执行所有微任务（清空微任务队列）\n  3. 渲染页面（如果需要）\n  4. 取一个宏任务执行\n}\n```\n\n事件循环不断检查调用栈是否为空。当调用栈为空时，事件循环从任务队列中取出一个任务（回调函数），将其压入调用栈执行。如此循环往复，实现异步任务的有序执行。\n\n**示例**\n\n```\nconsole.log('1'); // 同步代码\n\nsetTimeout(() => {\n  console.log('2'); // 宏任务\n  Promise.resolve().then(() => console.log('3')); // 微任务\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('4'); // 微任务\n  setTimeout(() => console.log('5'), 0); // 宏任务\n});\n\n// 输出顺序：1 → 4 → 2 → 3 → 5\n```\n\n事件循环每次从宏任务队列中取出一个宏任务执行。在执行宏任务过程中，可能会产生新的宏任务或微任务。\n\n在当前宏任务执行完毕后，事件循环会立即处理微任务队列中的所有微任务，直到微任务队列为空，才会去取下一个宏任务。\n\n### 执行优先级\n\n**同步代码 > 微任务 > 宏任务 > 渲染**\n\n**微任务的嵌套执行**\n\n微任务队列必须完全清空后，才会执行下一个宏任务或渲染"
  },
  {
    "id": "Promise",
    "title": "Promise",
    "answer": "`Promise` 是 JavaScript 中用于处理异步操作的一种对象。它提供了一种更结构化和可管理的方式来处理异步任务的结果。\n\n## **基本概念**\n\n-   `Promise` 对象有三种状态：\n\n<!---->\n\n-   -   `pending`（初始状态，既不是成功也不是失败）\n    -   `fulfilled`（操作成功完成）\n    -   `rejected`（操作失败）\n\n状态只能从 `pending` 转变为 `fulfilled` 或者 `rejected` ，且状态一旦改变就不可再变。\n\n## **创建** `Promise` **对象**\n\n使用 `new Promise((resolve, reject) => {...})` 来创建。在执行器函数中，异步操作成功时调用 `resolve` 函数来改变状态为 `fulfilled` 并传递结果值；异步操作失败时调用 `reject` 函数来改变状态为 `rejected` 并传递错误原因。\n\n## `Promise` **的方法**\n\n-   `then`：接收两个回调函数作为参数，第一个函数在 `Promise` 状态变为 `fulfilled` 时被调用，第二个函数（可选）在 `Promise` 状态变为 `rejected` 时被调用。它返回一个新的 `Promise` 对象，支持链式调用。\n-   `catch`：专门用于处理 `Promise` 被拒绝（`rejected`）的情况，相当于 `then` 方法中只处理错误的部分。它也返回一个新的 `Promise` 对象。\n-   `finally`：无论 `Promise` 的最终状态是成功还是失败，都会执行 `finally` 中指定的回调函数。它返回一个新的 `Promise` 对象，其状态和值与前一个 `Promise` 相同。\n\n## `Promise` **的链式调用**\n\n通过 `then` 方法的连续调用，可以形成一个 `Promise` 链，依次处理每个异步操作的结果，并将结果传递给下一个 `then` 。\n\n**错误处理：**\n\n如果在 `Promise` 链中的某个环节发生了错误，会沿着链传递，直到被 `catch` 方法捕获处理。  \n`Promise` **的组合：**\n\n-   `Promise.all`：接收一个 `Promise` 数组，只有当所有的 `Promise` 都成功时，返回的 `Promise` 才成功，结果是一个包含所有成功结果的数组。如果有一个 `Promise` 失败，整个组合就失败。\n-   `Promise.race`：接收一个 `Promise` 数组，只要其中一个 `Promise 成功或失败`，返回的 `Promise` 就会相应地成功或失败，并返回第一个完成的 `Promise` 的结果。\n\n## **优点**\n\n-   使异步代码更具可读性和可维护性。\n-   更好地处理错误。\n-   支持优雅的异步流程控制和组合。\n\n## 手写实现promise\n\n自定义 Promise 类，模拟原生 Promise 的基本功能\n\n```\nclass Promise{\n  /**\n   * 构造函数，初始化 Promise 实例\n   * @param {function} executor - 执行器函数，接收 resolve 和 reject 作为参数\n   */\n  constructor(executor){\n    // 初始化 Promise 状态为 pending\n    this.state = 'pending';\n    // 初始化 Promise 成功的值\n    this.value = undefined;\n    // 初始化 Promise 失败的原因\n    this.reason = undefined;\n    // 存储成功回调的数组\n    this.onResolvedCallbacks = [];\n    // 存储失败回调的数组\n    this.onRejectedCallbacks = [];\n\n    /**\n     * 改变 Promise 状态为 fulfilled，并传递成功的值\n     * @param {*} value - 成功的值\n     */\n    let resolve = value => {\n      // 只有状态为 pending 时才能改变状态\n      if (this.state === 'pending') {\n        // 将状态改为 fulfilled\n        this.state = 'fulfilled';\n        // 保存成功的值\n        this.value = value;\n        // 依次执行成功回调数组中的回调函数\n        this.onResolvedCallbacks.forEach(fn=>fn());\n      }\n    };\n\n    /**\n     * 改变 Promise 状态为 rejected，并传递失败的原因\n     * @param {*} reason - 失败的原因\n     */\n    let reject = reason => {\n      // 只有状态为 pending 时才能改变状态\n      if (this.state === 'pending') {\n        // 将状态改为 rejected\n        this.state = 'rejected';\n        // 保存失败的原因\n        this.reason = reason;\n        // 依次执行失败回调数组中的回调函数\n        this.onRejectedCallbacks.forEach(fn=>fn());\n      }\n    };\n\n    try{\n      // 执行执行器函数，并传入 resolve 和 reject\n      executor(resolve, reject);\n    } catch (err) {\n      // 若执行器函数抛出错误，调用 reject 方法\n      reject(err);\n    }\n  }\n\n  /**\n   * 为 Promise 实例添加成功和失败的回调函数，并返回一个新的 Promise 实例\n   * @param {function} onFulfilled - 成功回调函数\n   * @param {function} onRejected - 失败回调函数\n   * @returns {Promise} 一个新的 Promise 实例\n   */\n  then(onFulfilled,onRejected) {\n    // 若 onFulfilled 不是函数，将其转换为返回传入值的函数\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n    // 若 onRejected 不是函数，将其转换为抛出错误的函数\n    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };\n\n    let promise2 = new Promise((resolve, reject) => {\n      if (this.state === 'fulfilled') {\n        // 异步执行成功回调函数\n        setTimeout(() => {\n          try {\n            // 执行成功回调函数并获取结果\n            let x = onFulfilled(this.value);\n            // 解析结果\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            // 若执行过程中出现错误，调用 reject 方法\n            reject(e);\n          }\n        }, 0);\n      };\n\n      if (this.state === 'rejected') {\n        // 异步执行失败回调函数\n        setTimeout(() => {\n          try {\n            // 执行失败回调函数并获取结果\n            let x = onRejected(this.reason);\n            // 解析结果\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            // 若执行过程中出现错误，调用 reject 方法\n            reject(e);\n          }\n        }, 0);\n      };\n\n      if (this.state === 'pending') {\n        // 将成功回调函数添加到成功回调数组中\n        this.onResolvedCallbacks.push(() => {\n          // 异步执行成功回调函数\n          setTimeout(() => {\n            try {\n              // 执行成功回调函数并获取结果\n              let x = onFulfilled(this.value);\n              // 解析结果\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              // 若执行过程中出现错误，调用 reject 方法\n              reject(e);\n            }\n          }, 0);\n        });\n\n        // 将失败回调函数添加到失败回调数组中\n        this.onRejectedCallbacks.push(() => {\n          // 异步执行失败回调函数\n          setTimeout(() => {\n            try {\n              // 执行失败回调函数并获取结果\n              let x = onRejected(this.reason);\n              // 解析结果\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              // 若执行过程中出现错误，调用 reject 方法\n              reject(e);\n            }\n          }, 0)\n        });\n      };\n    });\n\n    // 返回新的 Promise 实例\n    return promise2;\n  }\n\n  /**\n   * 捕获 Promise 链中的错误\n   * @param {function} fn - 错误处理函数\n   * @returns {Promise} 一个新的 Promise 实例\n   */\n  catch(fn){\n    // 调用 then 方法，只传入失败回调函数\n    return this.then(null,fn);\n  }\n}\n\n/**\n * 解析 Promise 的结果\n * @param {Promise} promise2 - 新的 Promise 实例\n * @param {*} x - 上一个 Promise 的结果\n * @param {function} resolve - 解决 Promise 的函数\n * @param {function} reject - 拒绝 Promise 的函数\n */\nfunction resolvePromise(promise2, x, resolve, reject){\n  // 避免循环引用\n  if(x === promise2){\n    return reject(new TypeError('Chaining cycle detected for promise'));\n  }\n  // 标记是否已经调用过 resolve 或 reject\n  let called;\n  // 判断 x 是否为对象或函数\n  if (x != null && (typeof x === 'object' || typeof x === 'function')) {\n    try {\n      // 获取 x 的 then 方法\n      let then = x.then;\n      // 判断 then 是否为函数\n      if (typeof then === 'function') { \n        // 调用 then 方法\n        then.call(x, y => {\n          // 避免重复调用\n          if(called)return;\n          called = true;\n          // 递归解析 y\n          resolvePromise(promise2, y, resolve, reject);\n        }, err => {\n          // 避免重复调用\n          if(called)return;\n          called = true;\n          // 拒绝 Promise\n          reject(err);\n        })\n      } else {\n        // 若 then 不是函数，直接将 x 作为结果\n        resolve(x);\n      }\n    } catch (e) {\n      // 若执行过程中出现错误，避免重复调用\n      if(called)return;\n      called = true;\n      // 拒绝 Promise\n      reject(e); \n    }\n  } else {\n    // 若 x 不是对象或函数，直接将 x 作为结果\n    resolve(x);\n  }\n}\n\n/**\n * 返回一个状态为 fulfilled 的 Promise 实例\n * @param {*} val - 成功的值\n * @returns {Promise} 一个新的 Promise 实例\n */\n// resolve 方法\nPromise.resolve = function(val){\n  return new Promise((resolve,reject)=>{\n    // 调用 resolve 方法\n    resolve(val)\n  });\n}\n\n/**\n * 返回一个状态为 rejected 的 Promise 实例\n * @param {*} val - 失败的原因\n * @returns {Promise} 一个新的 Promise 实例\n */\n// reject 方法\nPromise.reject = function(val){\n  return new Promise((resolve,reject)=>{\n    // 调用 reject 方法\n    reject(val)\n  });\n}\n\n/**\n * 接受一个 Promise 数组，返回一个新的 Promise，只要数组中的任何一个 Promise 状态改变，新的 Promise 就会以相同的状态和结果结束\n * @param {Array<Promise>} promises - Promise 数组\n * @returns {Promise} 一个新的 Promise 实例\n */\n// race 方法 \nPromise.race = function(promises){\n  return new Promise((resolve,reject)=>{\n    for(let i=0;i<promises.length;i++){\n      // 为每个 Promise 添加成功和失败回调\n      promises[i].then(resolve,reject)\n    };\n  })\n}\n\n/**\n * 接受一个 Promise 数组，返回一个新的 Promise，只有当数组中的所有 Promise 都成功时，新的 Promise 才会成功，结果是一个包含所有 Promise 结果的数组；如果有任何一个 Promise 失败，新的 Promise 就会立即失败\n * @param {Array<Promise>} promises - Promise 数组\n * @returns {Promise} 一个新的 Promise 实例\n */\n// all 方法(获取所有的 promise，都执行 then，把结果放到数组，一起返回)\nPromise.all = function(promises){\n  // 存储所有 Promise 结果的数组\n  let arr = [];\n  // 记录已完成的 Promise 数量\n  let i = 0;\n\n  /**\n   * 处理每个 Promise 的结果\n   * @param {number} index - 结果在数组中的索引\n   * @param {*} data - 结果数据\n   */\n  function processData(index,data){\n    // 将结果存储到数组中\n    arr[index] = data;\n    // 已完成的 Promise 数量加 1\n    i++;\n    if(i == promises.length){\n      // 若所有 Promise 都已完成，调用 resolve 方法\n      resolve(arr);\n    };\n  };\n\n  return new Promise((resolve,reject)=>{\n    for(let i=0;i<promises.length;i++){\n      // 为每个 Promise 添加成功和失败回调\n      promises[i].then(data=>{\n        // 处理成功结果\n        processData(i,data);\n      },reject);\n    };\n  });\n}\n```\n\n#"
  },
  {
    "id": "js中的数据类型",
    "title": "js中的数据类型",
    "answer": "<h2 id=\"sVBgA\">数据类型有8种：</h2>\nundefined、null、boolean、string、number、object、symbol、bigint\n\n<h2 id=\"lDIko\">特别的：</h2>\nsymbol: 唯一的， 主要是为了解决属性、变量名的冲突问题\n\nbigint:表示大整数， 问了解决超出number最大范围的整数\n\n<h3 id=\"Jkb39\">symbol</h3>\n1. 创建唯一属性键，避免与常规的字符串属性键冲突\n\n```javascript\nconst mySymbol = Symbol(\"mySymbol\")\nconst obj = {}\nobj[mySymbol] = \"123\"\n```\n\n2. 模拟私有属性\n\n```javascript\n// 定义一个class类\nconst privateProperty = Symbol('private');\n\nclass MyClass {\n  constructor() {\n    this[privateProperty] = 'This is a private value';\n  }\n\n  getPrivateValue() {\n    return this[privateProperty];\n  }\n}\n// 使用class类\nconst instance = new MyClass();\n// console.log(instance) 会发现instance的属性键为Symbol类型， 外面在直接使用instance时是无法直接读取的， 只有通过提供的getPrivateValue方法才行\n```\n\n<h3 id=\"j78EJ\">bigint</h3>\n通过在整数后面添加`n`来定义一个bigint类型的值\n\n```javascript\nconst num = 434242342423423423423n\n```\n\n或者通过`BigInt()`进行转换\n\n```javascript\nBigInt(123)\n```\n\n<h2 id=\"re4Ic\">分类</h2>\n原始数据类型：undefined、null、boolean、string、number、symbol、bigint\n\n引用数据类型：object、function、array\n\n<h2 id=\"NHQ7W\">区别：</h2>\n原始数据类型和引用数据类型的区别\n\n1. 存储方式不同：\n    1. 原始数据类型主要存储在栈中，访问速度快；\n    2. 引用数据类型主要存储在堆中， 栈中存储的是数据的地址\n2. 复制方式不同：\n    1. 原始数据类型复制是创建一个完全独立的新空间存储拷贝的新数据， 修改新数据时旧数据不会发生改变\n    2. 引用数据类型复制是复制的引用地址，不管修改新旧数据哪一个本地都操作的是一套数据\n3. 比较方式不同：\n    1. 原始数据类型通过`===`比较时，直接比较的值\n    2. 引用数据类型通过`===`比较时， 比较的是栈中存储的引用地址。只有两个地址都指向同一个值时才为true\n4. 传递方式不同：\n\n首先得清楚一点， 函数传参时传递的是值的副本，根据原始数据类型和引用数据类型的特性，不难推断\n\n    1. 原始数据类型传递的是值的副本， 内部操作不用想外面的原始值\n    2. 引用数据类型传递的是地址的副本。本质操作的都是一套数据\n\n<h2 id=\"plyyc\">数据类型检测</h2>\n<h3 id=\"lckyR\">typeof</h3>\n1. `typeof`可以检测undefined、boolean、string、number、symbol、bigint\n2. null、object都会返回“object”\n3. 特殊的\n\n```javascript\nconst as = Symbol('asd') \ntypeof as // 'symbol'\ntypeof 42423423n // 'bigint'\n```\n\n<h3 id=\"bl8kf\">instanceof</h3>\n可以检测引用数据类型的数据， 不能检测原始数据类型. 原因：**其内部运行机制是判断在其原型链中能否找到该类型的原型**\n\n```javascript\n324243 instanceof Number // false\n[] instanceof Array // true\nconst a1 = () => {}\na1 instanceof Function // true\nconst b1 = {}\nb1 instanceof Object // true\n```\n\n<h3 id=\"PM2qW\"><font style=\"color:rgba(0, 0, 0, 0.85);\">Object.prototype.toString.call()</font></h3>\n可以准确地检测各种数据类型，返回一个形如 `\"[object Type]\"` 的字符串，其中 `Type` 是数据类型的名称。"
  },
  {
    "id": "this的指向",
    "title": "this",
    "answer": "首先this是一个指针， 指向当前调用函数的对象， 而不是函数本身。在不同的上下文中， this的指向不同，this具体指向谁，是函数的运行时决定的， 而不是函数定义时决定的。"
  },
  {
    "id": "原型与原型链、继承",
    "title": "原型与原型链、继承",
    "answer": "## **原型（Prototype）** \n\n每个函数在创建时，都会自动获得一个 `prototype` 属性，这个属性指向一个对象，称为该函数的原型对象。当使用 `new` 操作符基于这个函数创建对象实例时，实例的内部 `[[Prototype]]` （在大多数现代浏览器中，可以通过 `__proto__` 访问，但不推荐直接使用）会指向该函数的原型对象。\n\n原型对象的主要用途是实现属性和方法的共享与复用。在原型对象上定义的属性和方法，可以被通过该构造函数创建的所有实例访问和使用。\n\n```\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, I'm ${this.name}`);\n};\n\nlet person1 = new Person('Alice');\nlet person2 = new Person('Bob');\n\nperson1.sayHello(); \nperson2.sayHello(); \n```\n\n在上述示例中，`sayHello` 方法定义在 `Person` 函数的原型对象上，但 `person1` 和 `person2` 实例都可以调用它。\n\n## **原型链（Prototype Chain）**\n\n当访问一个对象的属性或方法时，如果在对象本身找不到，JavaScript 引擎会沿着对象的 `__proto__` 所指向的原型对象继续查找。如果在当前原型对象中仍然找不到，就会继续沿着当前原型对象的 `__proto__` 向上查找，如此形成一个链式结构，这就是原型链。\n\n原型链的顶端是 `Object.prototype`，如果在整个原型链中都没有找到要访问的属性或方法，最终会返回 `undefined` 。\n```\nfunction Animal() {}\nAnimal.prototype.eat = function() {\n  console.log('Eating...');\n};\n\nfunction Dog() {}\nDog.prototype = new Animal();\n\nlet dog = new Dog();\ndog.eat(); \n```\n\n在这个例子中，创建的 `dog` 对象本身没有 `eat` 方法，但通过原型链在 `Animal` 的原型对象上找到了 `eat` 方法。\n\n## **prototype与**__proto__\n\n-   `prototype`：这是函数对象所特有的属性。当使用 `new` 操作符基于一个函数创建对象实例时，新创建的对象的 `__proto__` 会指向该函数的 `prototype` 对象。例如，上面的构造函数 `Person` ，`Person.prototype` 上定义的属性和方法可以被通过 `new Person()` 创建的实例访问和继承。\n-   `__proto__`：这是大多数对象都具有的一个内部属性（在 ES6 中，更推荐使用 `Object.getPrototypeOf()` 和 `Object.setPrototypeOf()` 方法来操作对象的原型）。它用于建立对象与原型对象之间的链接，从而实现属性的查找和继承。\n\n简单来说，`prototype` 用于定义构造函数的原型，而 `__proto__` 用于连接对象和其对应的原型。\n\n## 继承\n\n说到原型就不得不说一下js中的继承。\n\n继承的主要目的是代码复用和实现对象之间的层次关系。通过继承，可以创建具有相似特征和行为的对象类，减少重复代码，并使代码结构更清晰、更易于维护。\n\njs中继承分为两种：基于原型的继承、基于class的继承\n\n### 基于原型的继承方式\n\n#### 原型链继承\n\n原理：将子类的原型对象设置为父类的实例\n\n不足：\n\n1.  引用类型属性被共享\n1.  无法向父类构造函数传参。因为父类构造函数被挂载在prototype上， 所以子类new时传递进来的参数无法直接传递到Parent上\n\n```\nfunction Parent() {\n    this.colors = [\"red\", \"blue\"];\n}\n\nfunction Child() {}\n\nChild.prototype = new Parent();\n\nlet child1 = new Child();\nchild1.colors.push(\"green\");\n\nlet child2 = new Child();\nconsole.log(child2.colors); // [\"red\", \"blue\", \"green\"]  引用类型被共享\n```\n\n#### 借用构造函数继承\n\n原理：在子类构造函数中通过 `call()` 或 `apply()` 方法调用父类构造函数来继承属性,解决了引用类型共享和传参问题.\n\n不足：函数无法复用。child1、child2中都单独有一个独立的sayHello方法\n\n```\nfunction Parent(name) {\n  this.name = name;\n  this.colors = [\"red\", \"blue\"];\n  this.sayHello = function() {\n    console.log(`Hello, I'm ${this.name}`);\n  };\n}\n\nfunction Child(name) {\n  Parent.call(this, name);\n}\n\nlet child1 = new Child(\"John\");\nchild1.colors.push(\"green\");\n\n\nlet child2 = new Child(“bob”);\n```\n\n#### 组合式继承\n\n原理：结合原型链继承和借用构造函数继承，用原型链继承方法，用借用构造函数继承实例属性\n\n不足：父类构造函数会被调用两次\n\n```\nfunction Parent(name) {\n    this.name = name;\n    this.colors = [\"red\", \"blue\"];\n}\n\nParent.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nfunction Child(name, age) {\n    Parent.call(this, name);\n    this.age = age;\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nlet child = new Child(\"John\", 10);\n```\n\n#### 原型式继承\n\n原理：创建一个函数， 在函数内部创建一个临时的构造函数，将函数传进来的对象作为构造函数的原型，然后返回这个临时构造的对象实例。\n\n不足：引用类型属性被共享\n\n```\nfunction object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nlet person = {name: \"John\"};\nlet anotherPerson = object(person);\n```\n\n#### 寄生式继承\n\n原理：基于原型式继承创建一个新对象，然后为新对象添加额外的属性和方法。\n\n```\nfunction createAnother(original) {\n    let clone = object(original);\n    clone.sayHi = function() {\n        console.log(\"Hi\");\n    };\n    return clone;\n}\n\nlet person = {name: \"John\"};\nlet anotherPerson = createAnother(person);\n```\n\n#### 寄生组合式继承\n\n原理：被认为是 JavaScript 中最理想的继承方式。它通过创建一个空的中间对象，将中间对象的原型指向父类的原型，然后将子类的原型指向这个中间对象，避免了父类构造函数的重复调用。\n\n```\nfunction inheritPrototype(subType, superType) {\n    let prototype = Object.create(superType.prototype);\n    prototype.constructor = subType;\n    subType.prototype = prototype;\n}\n\nfunction Parent() {}\nParent.prototype.someMethod = function() {}\n\nfunction Child() {}\ninheritPrototype(Child, Parent);\n```\n\n### 基于class的继承方式\n\n#### extends-推荐实际使用\n\n1.  语法更清晰和简洁，更接近传统面向对象编程语言的语法，易于理解和使用。\n1.  `extends` 关键字明确表示了继承关系。\n1.  通过 `super` 关键字方便地调用父类的构造函数和方法。\n1.  支持方法的重写和扩展，使得代码的结构更加清晰和可维护。\n\n```\n// 父类\nclass Parent {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayHello() {\n    console.log(`Hello, I'm ${this.name}`);\n  }\n}\n\n// 子类继承父类\nclass Child extends Parent {\n  constructor(name, age) {\n    // 调用父类的构造函数\n    super(name); \n    this.age = age;\n  }\n\n  // 子类可以重写父类的方法\n  sayHello() {\n    console.log(`Hello, I'm ${this.name} and I'm ${this.age} years old`);\n  }\n}\n\nlet child = new Child('John', 10);\nchild.sayHello(); \n```\n\n## call、apply、bind的实现\n\n上面我们了解了原型、原型链以及继承的一些知识点。知道通过call、apply改变指针也能实现继承。那call、apply、bind是如果改变指针指向的呢？这个又跟原型、原型链有什么关系呢？\n\n我们自己来实现一下这三个方法就明白了\n\n### call\n\n```\nFunction.prototype.myCall = function(context, ...args){\n  // 判断调用对象是否为函数\n  if(typeof this !== 'function'){\n    throw new TypeError('not a function')\n  }\n  // 判断context是否传入，如果未传入则设置为window\n  context = context || window\n  // 给context创建一个Symbol属性以免覆盖原有的属性\n  const fn = Symbol()\n  context[fn] = this\n  // 调用函数\n  let res = context[fn](...args)\n  // 将属性删除\n  delete context[fn]\n  // 返回结果\n  return res\n}\n```\n\n### apply\n\napply与call的区别在于参数格式不同\n\n```\nFunction.prototype.myApply = function (context, args) {\n  if(typeof this !== 'function'){\n    throw new TypeError('not a function');\n  }\n  context = context || window;\n  const fn = Symbol()\n  context[fn] = this\n  let res = context[fn](args);\n  delete context[fn];\n  return res;\n}\n```\n\n### bind\n\nbind方法执行后会返回一个函数，结合apply可以改变返回的函数的指针指向\n\n```\nFunction.prototype.myBind = function(context,...args){\n  let self = this;\n  console.log(args);\n  return function(){\n    return self.myApply(context,args)\n  }\n}\n```"
  },
  {
    "id": "字符串的常用方法",
    "title": "字符串的常用方法",
    "answer": "## 常用方法\n\n1.  `charAt(index)`：返回指定索引位置的字符。\n1.  `charCodeAt(index)`：返回指定索引位置字符的 Unicode 值。\n1.  `concat(str1, str2,...)`：连接两个或多个字符串。\n1.  `indexOf(searchValue, fromIndex)`：返回指定字符串在原字符串中首次出现的索引，如果未找到则返回 -1。\n1.  `lastIndexOf(searchValue, fromIndex)`：返回指定字符串在原字符串中最后一次出现的索引，如果未找到则返回 -1。\n1.  `slice(start, end)`：提取字符串的一部分并返回新字符串。\n1.  `substr(start, length)`：从指定位置开始提取指定长度的字符并返回新字符串。\n1.  `substring(start, end)`：提取字符串在两个指定索引之间的部分并返回新字符串。\n1.  `toLowerCase()`：将字符串转换为小写。\n1.  `toUpperCase()`：将字符串转换为大写。\n1.  `split(separator, limit)`：通过指定的分隔符将字符串分割成数组。\n1.  `replace(searchValue, replacement)`：替换字符串中的匹配项。\n1.  `trim()`：去除字符串两端的空格。\n1.  `startsWith(searchString, position)`：检查字符串是否以指定的字符串开头。\n1.  `endsWith(searchString, length)`：检查字符串是否以指定的字符串结尾。\n1.  `includes(searchString, position)`：检查字符串是否包含指定的子字符串。\n1.  `match(regexp)`：使用正则表达式在字符串中查找匹配项，并返回一个数组。\n1.  `search(regexp)`：使用正则表达式搜索字符串，并返回匹配的起始索引。\n\n## 字符串截取的方法对比\n\n1.  `slice(start, end)` 方法：\n\n-   -   `start`：必需。指定开始提取字符的位置。如果为负数，则从字符串末尾开始计数（例如，`-1` 表示最后一个字符）。\n    -   `end`：可选。指定结束提取字符的位置（不包括该位置的字符）。如果省略，则提取到字符串末尾。如果为负数，则从字符串末尾开始计数。\n\n```\nlet str = \"Hello World\";\nlet result1 = str.slice(0, 5); // \"Hello\"\nlet result2 = str.slice(-5); // \"World\"\n```\n\n2.  `substring(start, end)` 方法：\n\n-   -   与 `slice` 方法类似，但 `start` 和 `end` 不能为负数。如果为负数，会被当作 0 处理。\n\n```\nlet str = \"Hello World\";\nlet result3 = str.substring(0, 5); // \"Hello\"\n```\n\n3.  `substr(start, length)` 方法：\n\n-   -   `start`：必需。指定开始提取字符的位置。如果为负数，则从字符串末尾开始计数。\n    -   `length`：可选。指定提取的字符数量。\n\n```\nlet str = \"Hello World\";\nlet result4 = str.substr(6, 5); // \"World\"\nlet result5 = str.substr(-5, 5); // \"World\"\n```\n\n总结：`slice` 方法在处理负数索引时更灵活，而 `substring` 方法要求索引不能为负数。`substr` 方法则通过指定起始位置和长度来截取字符串。"
  },
  {
    "id": "数组的常用方法",
    "title": "数组的常用方法",
    "answer": "## 常用方法\n\n1.  `push()`：在数组末尾添加一个或多个元素，并返回新的数组长度。\n1.  `pop()`：删除数组的最后一个元素，并返回被删除的元素。\n1.  `shift()`：删除数组的第一个元素，并返回被删除的元素。\n1.  `unshift()`：在数组开头添加一个或多个元素，并返回新的数组长度。\n1.  `slice(start, end)`：返回一个新的数组，包含从 `start` 到 `end`（不包括 `end`）的元素。\n1.  `splice(start, deleteCount, item1, item2,...)`：在指定位置添加或删除元素。\n1.  `concat()`：连接两个或多个数组，并返回一个新的数组。\n1.  `join(separator)`：将数组的所有元素连接成一个字符串，通过指定的分隔符分隔。\n1.  `reverse()`：反转数组的元素顺序。\n1.  `sort()`：对数组元素进行排序。\n1.  `includes(item)`：检查数组是否包含指定的元素，返回 `true` 或 `false` 。\n1.  `indexOf(item)`：返回指定元素在数组中的第一个索引，如果不存在则返回 `-1` 。\n1.  `lastIndexOf(item)`：返回指定元素在数组中的最后一个索引，如果不存在则返回 `-1` 。\n1.  `forEach(callback)`：对数组的每个元素执行指定的函数。\n1.  `map(callback)`：创建一个新数组，其结果是对原数组的每个元素调用提供的函数后的返回值。\n1.  `filter(callback)`：创建一个新数组，其中包含通过提供的函数实现的测试的所有元素。\n1.  `reduce(callback, initialValue)`：对数组中的每个元素执行一个提供的 reducer 函数，将其结果汇总为单个返回值。\n1.  `some(callback)`：检查数组中是否至少有一个元素通过提供的函数实现的测试，返回 `true` 或 `false` 。\n1.  `every(callback)`：检查数组中的所有元素是否都通过提供的函数实现的测试，返回 `true` 或 `false` 。\n\n## 循环遍历数组的方法\n\n1.  `for` 循环：\n\n```\nfor(let i = 0; i < array.length; i++) {\n  // 在这里访问数组元素 array[i]\n  console.log(array[i]);\n}\n```\n\n这是最基本的循环方式。通过定义一个索引变量 `i` ，从 0 开始，每次循环增加 1，直到索引小于数组的长度。在循环体中，可以通过 `array[i]` 来访问每个元素。  \n2.`for...of` 循环：\n\n```\nfor (let element of array) {\n  // 在这里访问数组元素 element\n  console.log(element);\n}\n```\n\n`for...of` 循环会遍历可迭代对象（包括数组）的值。每次循环，变量 `element` 都会被赋值为数组中的下一个元素。\n\n3.  `forEach` 方法：\n\n```\narray.forEach(function(element, index, array) {\n  // 在这里访问数组元素 element 和索引 index\n  console.log(element);\n});\n```\n\n`forEach` 方法为数组的每个元素执行一次提供的函数。这个函数接受三个参数：当前元素、当前元素的索引和数组本身。\n\n4.  `map` 方法：\n\n```\nlet newArray = array.map(function(element, index, array) {\n  // 对每个元素进行处理并返回新的值\n  return element * 2;\n});\n```\n\n`map` 方法创建一个新数组，其元素是对原数组的每个元素调用提供的函数后的返回值。\n\n5.  `filter` 方法：\n\n```\nlet filteredArray = array.filter(function(element, index, array) {\n  // 根据条件返回 true 或 false，决定元素是否保留\n  return element > 5;\n});\n```\n\n`filter` 方法创建一个新数组，其中包含通过提供的函数实现的测试的所有元素。\n\n6.  `reduce` 方法：\n\n```\nlet result = array.reduce(function(accumulator, currentValue, currentIndex, array) {\n  // 对每个元素进行累积计算\n  return accumulator + currentValue;\n}, initialValue);\n```\n\n`reduce` 方法对数组中的每个元素执行一个提供的 `reducer` 函数（升序执行），将其结果汇总为单个返回值。`reducer` 函数接受四个参数：累计器、当前值、当前索引和数组本身。第二个参数 `initialValue` 是可选的，用于指定初始的累计器值。\n\n7.  `some`、`every`也会遍历数组，但它们不一定会执行完整个数组的遍历，一旦有满足条件的元素就会终止循环操作"
  },
  {
    "id": "箭头函数和普通函数的区别",
    "title": "箭头函数和普通函数的区别",
    "answer": "## 语法\n箭头函数通过()={}声明， 语法更简洁。并且根据情况可以省略写法\n普通函数通过function关键字来声明\n## this\n首先就是箭头函数自己内部没有自己的this， 而是继承自外面的this， 同时call、apply、bind方法不能改变箭头函数内的this指向\n## arguments\n箭头函数没有arguments， 内部访问的是外部函数体的arguments\n## prototype\n箭头函数没有原型链\n## 构造\n箭头函数不能作为构造函数使用， 也就是不能new一个新的对象出来"
  }
]